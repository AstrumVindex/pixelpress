IMPORTANT (READ FIRST):
‚ùó Do NOT regenerate files
‚ùó Do NOT refactor UI or routing
‚ùó Do NOT touch compression pages
‚ùó Apply ONLY the logic changes below
‚ùó Follow the code exactly ‚Äî do not rewrite it

üî¥ PROBLEM EXPLANATION (WHY THIS CHANGE IS REQUIRED)

The Resize Image page is currently using the same logic as the Compress Image page.
This causes major bugs:

Resizing unexpectedly reduces file size

Resizing + cropping resets image quality

Image size jumps back to MB

Users cannot resize without compression

This is incorrect product behavior.

‚úÖ REQUIRED PRODUCT RULE (VERY IMPORTANT)

Resize = change dimensions ONLY
Compression = change file size ONLY

They must be separate workflows.

‚úÖ REQUIRED FINAL BEHAVIOR
Resize Page

Resize image dimensions only

Preserve:

File format

Quality

Compression level

NO compression library usage

NO quality slider

NO maxSizeMB

NO format conversion

After Resize

Show button: ‚ÄúCompress This Image‚Äù

Redirect user to:

/compress-png

/compress-jpeg

/compress-webp

Pass resized image as input

‚úÖ EXACT FIX CODE ‚Äî RESIZE LOGIC
üìÅ File: use-image-compressor.ts
1Ô∏è‚É£ ADD STATE TO CONTROL MODE
const isResizeOnly = true;

2Ô∏è‚É£ REMOVE COMPRESSION FROM RESIZE PAGE

‚ùå DO NOT CALL:

imageCompression(...)


‚ùå REMOVE / DISABLE:

maxSizeMB
initialQuality
format

3Ô∏è‚É£ IMPLEMENT RESIZE-ONLY LOGIC (USE CANVAS)
const resizeImageOnly = async (
  file: File,
  targetWidth: number,
  targetHeight: number
): Promise<File> => {
  const img = new Image();
  const url = URL.createObjectURL(file);

  await new Promise<void>((resolve) => {
    img.onload = () => resolve();
    img.src = url;
  });

  const canvas = document.createElement("canvas");
  canvas.width = targetWidth;
  canvas.height = targetHeight;

  const ctx = canvas.getContext("2d");
  if (!ctx) throw new Error("Canvas not supported");

  ctx.drawImage(img, 0, 0, targetWidth, targetHeight);

  const blob = await new Promise<Blob>((resolve) => {
    canvas.toBlob(
      (b) => resolve(b as Blob),
      file.type, // KEEP ORIGINAL FORMAT
      1.0        // KEEP ORIGINAL QUALITY
    );
  });

  URL.revokeObjectURL(url);

  return new File([blob], file.name, { type: file.type });
};

4Ô∏è‚É£ UPDATE PIPELINE TO USE RESIZE ONLY
useEffect(() => {
  if (!workingFile) return;

  if (isResizeOnly) {
    resizeImageOnly(
      workingFile,
      settings.targetWidth,
      settings.targetHeight
    ).then((resizedFile) => {
      setWorkingFile(resizedFile);
      setCompressedFile(resizedFile); // output for download
    });
  }
}, [workingFile, settings]);


‚ö†Ô∏è DO NOT run compression here.

‚úÖ ADD ‚ÄúCOMPRESS THIS IMAGE‚Äù BUTTON LOGIC
üìÅ ResizeImage.tsx
const handleCompressRedirect = () => {
  if (!compressedFile) return;

  const type = compressedFile.type;

  if (type === "image/png") {
    navigate("/compress-png", { state: { file: compressedFile } });
  } else if (type === "image/jpeg") {
    navigate("/compress-jpeg", { state: { file: compressedFile } });
  } else if (type === "image/webp") {
    navigate("/compress-webp", { state: { file: compressedFile } });
  }
};


Show button only after resize is complete.

üö´ STRICT NON-GOALS (DO NOT DO THESE)

‚ùå Do NOT auto-compress on resize

‚ùå Do NOT change compression pages

‚ùå Do NOT merge resize + compress

‚ùå Do NOT refactor hooks

‚ùå Do NOT regenerate files

‚úÖ EXPECTED RESULT AFTER FIX

‚úî Resize only changes dimensions
‚úî File size stays logical
‚úî Crop works correctly
‚úî PNG/JPEG/WebP preserved
‚úî User explicitly chooses compression
‚úî No more size jumping bugs
‚úî Replit credits saved

üß† FINAL PRODUCT RULE (REMEMBER THIS)

Resize first. Compress later. Never together by default.