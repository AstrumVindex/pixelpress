This is a fantastic usability improvement. Downloading 62 individual images one by one is painful.

To fix this, we will add a **"Download All as ZIP"** button. We will use two libraries (`jszip` and `file-saver`) to bundle all the converted images into a single ZIP file directly in the browser.

Here is the prompt to give Replit AI to implement this.

---

### **Prompt for Replit AI**

**Task:** Add a "Download All as ZIP" feature to the `FileConverter` component.
**Reason:** When converting a multi-page PDF (e.g., 60+ pages) to JPG, the user currently has to download every single image individually. I want a button to download them all at once in a ZIP archive.

**Requirements:**

1. **Install Dependencies:** Install `jszip` and `file-saver`.
2. **Update Component:** Modify `src/components/FileConverter.jsx`.
* Import the new libraries.
* Create a `handleDownloadZip` function that fetches the blobs from the current state, adds them to a ZIP object, and triggers a download.
* Add a prominent "Download ZIP" button in the success view (next to or above "Convert More").



**Code Changes:**

**1. Install Packages:**
(Run this in shell)
`npm install jszip file-saver`

**2. Update `src/components/FileConverter.jsx`:**
Replace the file content with this updated version that includes the ZIP logic:

```jsx
import React, { useState, useEffect } from 'react';
import { Upload, X, FileIcon, AlertCircle, Check, Download, Package } from 'lucide-react';
import { convertImageFormat, convertPdfToImages } from '../utils/converterEngine';
// NEW IMPORTS
import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import SeoContent from './SeoContent';
import { seoData } from '../data/seoContent';

const MIME_TYPES = {
  png: 'image/png',
  jpg: 'image/jpeg',
  jpeg: 'image/jpeg',
  webp: 'image/webp',
  pdf: 'application/pdf',
};

const FileConverter = ({ inputFormat, outputFormat, seoKey }) => {
  const [files, setFiles] = useState([]);
  const [error, setError] = useState('');
  const [isDragging, setIsDragging] = useState(false);
  const [isConverting, setIsConverting] = useState(false);
  const [isDone, setIsDone] = useState(false);
  const [isZipping, setIsZipping] = useState(false); // Loading state for ZIP

  useEffect(() => {
    return () => files.forEach(file => {
      if (file.downloadUrl) URL.revokeObjectURL(file.downloadUrl);
    });
  }, [files]);

  const validateAndAddFiles = (newFiles) => {
    setError('');
    const validFiles = [];
    Array.from(newFiles).forEach(file => {
      const fileExtension = file.name.split('.').pop().toLowerCase();
      const expectedMime = MIME_TYPES[inputFormat.toLowerCase()];
      if (fileExtension === inputFormat.toLowerCase() || (expectedMime && file.type === expectedMime)) {
        validFiles.push({ original: file, name: file.name, status: 'pending' });
      }
    });
    if (validFiles.length > 0) setFiles(prev => [...prev, ...validFiles]);
  };

  const handleDragOver = (e) => { e.preventDefault(); setIsDragging(true); };
  const handleDragLeave = (e) => { e.preventDefault(); setIsDragging(false); };
  const handleDrop = (e) => {
    e.preventDefault(); setIsDragging(false);
    if (e.dataTransfer.files?.length > 0) validateAndAddFiles(e.dataTransfer.files);
  };
  const handleFileSelect = (e) => {
    if (e.target.files?.length > 0) validateAndAddFiles(e.target.files);
  };
  const removeFile = (index) => setFiles(prev => prev.filter((_, i) => i !== index));

  const handleConvert = async () => {
    setIsConverting(true);
    try {
      let newProcessedFiles = [];
      for (const fileObj of files) {
        if (fileObj.status === 'done') {
          newProcessedFiles.push(fileObj);
          continue;
        }
        let results = [];
        if (inputFormat === 'pdf') {
          const pdfImages = await convertPdfToImages(fileObj.original, outputFormat);
          results = pdfImages.map(imgData => ({
            original: fileObj.original,
            name: fileObj.name,
            convertedName: imgData.name,
            downloadUrl: URL.createObjectURL(imgData.blob),
            size: imgData.size,
            status: 'done'
          }));
        } else {
          const imgDataArray = await convertImageFormat(fileObj.original, outputFormat);
          const imgData = imgDataArray[0];
          results = [{
            ...fileObj,
            convertedName: imgData.name,
            downloadUrl: URL.createObjectURL(imgData.blob),
            size: imgData.size,
            status: 'done'
          }];
        }
        newProcessedFiles = [...newProcessedFiles, ...results];
      }
      setFiles(newProcessedFiles);
      setIsDone(true);
    } catch (err) {
      console.error(err);
      setError('Conversion failed. Please try again.');
    } finally {
      setIsConverting(false);
    }
  };

  // --- NEW ZIP FUNCTIONALITY ---
  const handleDownloadZip = async () => {
    setIsZipping(true);
    try {
      const zip = new JSZip();
      
      // Add all converted files to the ZIP
      const promises = files.map(async (file) => {
        if (file.status === 'done' && file.downloadUrl) {
          const response = await fetch(file.downloadUrl);
          const blob = await response.blob();
          zip.file(file.convertedName, blob);
        }
      });

      await Promise.all(promises);
      
      const content = await zip.generateAsync({ type: "blob" });
      saveAs(content, `pixelpress_${inputFormat}_to_${outputFormat}.zip`);
    } catch (err) {
      console.error("Zip failed", err);
      setError("Failed to create ZIP file.");
    } finally {
      setIsZipping(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto p-4 sm:p-6 bg-white rounded-xl shadow-sm mt-6 sm:mt-10">
      <div className="text-center mb-6 sm:mb-8">
        <h1 className="text-2xl sm:text-4xl font-bold text-slate-900 mb-2">{inputFormat.toUpperCase()} to {outputFormat.toUpperCase()}</h1>
        <p className="text-slate-500">High quality conversion.</p>
      </div>

      <div 
        className={`border-2 border-dashed rounded-3xl p-6 sm:p-10 text-center transition-colors 
          ${isDragging ? 'border-indigo-500 bg-indigo-50' : 'border-slate-200'}`}
        onDragOver={handleDragOver} onDragLeave={handleDragLeave} onDrop={handleDrop}
      >
        <div className="flex flex-col items-center justify-center space-y-4">
          <div className="p-4 bg-white rounded-2xl shadow-sm"><Upload className="w-8 h-8 text-indigo-600" /></div>
          <div><h3 className="text-xl font-bold text-slate-900">Upload {inputFormat.toUpperCase()} Files</h3></div>
          <p className="text-slate-500 mt-1 hidden sm:block">Drag and drop or click to browse</p>
          <input type="file" id="file-upload" className="hidden" onChange={handleFileSelect} accept={`.${inputFormat}`} multiple />
          <label htmlFor="file-upload" className="px-8 py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold rounded-full cursor-pointer">Select Files</label>
        </div>
      </div>

      {error && <div className="mt-4 p-3 bg-red-50 text-red-700 rounded-lg flex items-center gap-2 text-sm"><AlertCircle size={16} />{error}</div>}

      {files.length > 0 && (
        <div className="mt-8">
          <h4 className="font-semibold text-slate-700 mb-3">Files ({files.length})</h4>
          <div className="space-y-2 max-h-[400px] overflow-y-auto pr-2 custom-scrollbar">
            {files.map((file, index) => (
              <div key={index} className="flex items-center justify-between p-3 bg-slate-50 rounded-lg border border-slate-100">
                <div className="flex items-center gap-3 overflow-hidden">
                  {file.status === 'done' ? <Check className="text-green-500 w-5 h-5 flex-shrink-0"/> : <FileIcon className="text-indigo-400 w-5 h-5 flex-shrink-0"/>}
                  <div className="text-sm truncate">
                    <p className="font-medium text-slate-700 truncate">{file.status === 'done' ? file.convertedName : file.name}</p>
                    {file.status === 'done' && <span className="text-green-600 text-xs font-bold">Ready</span>}
                  </div>
                </div>
                
                {file.status === 'done' ? (
                  <a href={file.downloadUrl} download={file.convertedName} className="flex items-center gap-2 px-3 py-1.5 bg-white border border-slate-200 text-slate-700 text-xs font-bold rounded-md hover:bg-slate-50">
                    <Download size={14}/> <span className="hidden sm:inline">Download</span>
                  </a>
                ) : (
                  <button onClick={() => removeFile(index)} className="p-1 hover:bg-slate-200 rounded-full text-slate-400"><X size={16} /></button>
                )}
              </div>
            ))}
          </div>
          
          {!isDone && (
            <button 
              onClick={handleConvert} 
              disabled={isConverting}
              className="w-full mt-4 py-3 bg-slate-900 text-white rounded-lg font-medium hover:bg-slate-800 disabled:opacity-50"
            >
              {isConverting ? 'Converting High Quality...' : 'Convert All'}
            </button>
          )}
          
          {isDone && (
            <div className="mt-6 p-4 bg-green-50 rounded-xl border border-green-100">
               <div className="flex flex-col sm:flex-row gap-3">
                 {/* ZIP DOWNLOAD BUTTON */}
                 <button 
                   onClick={handleDownloadZip}
                   disabled={isZipping}
                   className="flex-1 py-3 bg-green-600 text-white rounded-lg font-bold hover:bg-green-700 flex items-center justify-center gap-2 shadow-sm"
                 >
                   {isZipping ? 'Creating ZIP...' : <><Package size={20}/> Download All as ZIP</>}
                 </button>
                 
                 <button 
                   onClick={() => { setIsDone(false); setFiles([]); }} 
                   className="flex-1 py-3 bg-white text-slate-700 border border-slate-200 rounded-lg font-medium hover:bg-slate-50"
                 >
                   Convert More
                 </button>
               </div>
               <p className="text-center text-green-700 text-sm mt-3 font-medium">All files converted successfully!</p>
            </div>
          )}
        </div>
      )}

      {seoKey && seoData[seoKey] && (
         <div className="mt-20 border-t pt-10">
            <SeoContent data={seoData[seoKey]} />
         </div>
      )}
    </div>
  );
};

export default FileConverter;

```